# :shipit:
# Flutter

## Общее
Flutter - кроссплатформенный UI фреймворк. Идея крайне простая - есть много платформ, хорошо было бы писать под них код, используя что-то одно, что позволит сократить затраты. Flutter получился крайне удачным решением, сейчас есть поддержка всех основных платформ. По сути, сейчас на Flutter'е можно писать приложения любой сложности. Говоря о недостатках Flutter'а, можно назвать Dart, но с оговоркой. Dart прекрасный язык, современный, удобный, но всё-таки язык одного фреймворка, не все разработчики захотят освоить Dart, чтобы использовать Flutter. Фреймворк делится на три основных слоя - непосредственно часть на Dart'е, с которой и работает разработчик, движок, написанный на C/C++ и платформенный код.

## Widget, Element, RenderObject
Во Flutter'е есть 3 основных дерева. Widgets tree, Elements tree и RenderObjects.
### Widgets tree
Widget - неизменяемая и легковесная конфигурация. Widgets tree на самом деле не является деревом как структурой, просто так удобно называть его. Widgets tree отвечает за декларирование и хранение свойств. 
### Elements tree
Element - представление виджета в дереве. Element'ы являются более тяжёлыми и живучими сущностями, активно переиспользуются фреймворком. Жизненный цикл Element'а - создание после вызова Widget.createElement, встраивание в дерево с помощью метода mount, активное состояние (отображается на экране), далее, если во время построения нового кадра Flutter пробует связать Element с изменённым Widget'ом. Если не получается, старый Element удаляется, а новый создаётся и встраивается на место старого. Родительный Element может деактивировать с помощью метода deactivate дочерний Element, если до конца построения кадра этот Element снова не станет активным, то он удалится из дерева. BuildContext у Widget'а по сути и есть Element. Elements tree отвечает за создание иерархии и управление связями.
### RenderObject
RenderObject - это сущность дерева визуализации. Отвечает за отрисовку и расположение этого объекта в дереве. RenderObjects tree отвечает за отрисовку и позиционирование.
Flutter идёт по дереву виджетов сверху вниз, для очередного виджета создаётся элемент, а для него уже создаётся RenderObject, если элемент не является StatefulElement, StatelessElement или ProxyElement, в элементе сохраняются ссылки на виджет и RenderObject. Благодаря такой системе с 3 деревьями, Flutter может работать быстро, ведь пересоздавать легковесные виджеты очень легко, а тяжёлые элементы переиспользуются по максимуму.

## Stateless и Stateful виджеты
И Stateless, и Stateful виджеты являются неизменяемыми, однако Stateful не имеет метода build, у него есть метод CreateState, а вот как раз этот State уже является изменяемым. Stateless виджеты стоит использовать для декомпозиции каких-то неизменяемых частей интерфейса. Stateful также можно использовать для декомпозиции, однако чем меньше наследников будет у этого виджета, чем меньшую часть дерева придётся перестраивать. State всегда связан со своим BuildContext'ом. Сначала у Stateful виджета создаётся State с помощью вызова createState, после уже в классе State вызывается initState, в нём можно инициализировать какие-то данные, didChangeDependencies вызывается после initState и если об этом просит InheritedWidget, build возвращает конфигурацию виджета, также этот метод должен быть чистым, т.к. неизвестно, как часто он будет вызываться, didUpdateWidget вызывается если он обновился родитель, в этот метод передаётся старый виджет, который можно сравнить с текущим, dispose вызывается, когда виджет убирается из дерева. У элемента есть геттер mounted - он позволяет определить, связан ли State с элементов.

## BuildContext
BuildContext это интерфейс Element'а, который позволяет получить доступ к дереву Element'ов. Можно использовать методы получения InheritedWidget'а, RenderObject'а.

## InheritedWidget
InheritedWidget - прокси виджет, который позволяет передавать данные вниз по дереву за константное время. Возможно это благодаря тому, что элемент хранит хэш таблицу Inherit'ов. У Inherit'а обязательно должен быть child, а также переопределён метод updateShouldNotify, в котором объясняется логика, когда нужно говорить дочерним виджетам о том, что они должны перерисоваться. С помощью метода dependOnInheritedWidgetOfExactType можно подписаться на изменения Inherit'а. Используя InheritedNotifier можно унаследовать его от Listenable, благодаря чему можно будет автоматически уведомлять подписчиков об изменениях. Используя InheritedModel можно разделять изменяемые данные и более тонко настраивать метод updateShouldNotify. Можно также всегда возвращать из этого метода false, тогда получится простой DI контейнер. InheritedWidget используется во всех популярных стейт менеджерах, Provider полностью основан на нём.

## Constraints

## Animation

## Navigation

## Widgets

## Lifting state up
Как следует из названия, суть паттерна Lifting state up заключается в выносе состояния, в случае Flutter'а, вверх по дереву. Благодаря тому, как Flutter обрабатывает изменение UI, Lifting state up работает довольно неплохо. Разработчику не нужно самому заботиться о перерисовке, при изменении данных Flutter сам сделает всю работу. Однако стоит понимать, что при изменении данных, к примеру, InheritedWidget'а, будет перерисоваться всё дерево под ним. Для реализации можно использовать уже упомянутые InheritedWidget'ы, можно искать виджет с состоянием напрямую через контекст, а также можно использовать Provider. Также удобно использовать в связке с ChangeNotifier'ом

https://academy.yandex.ru/handbook/flutter/articlewidgets-basics-stless-stful-inherited

https://habr.com/ru/articles/501862

https://www.youtube.com/watch?v=tu09RBytvHk

https://www.youtube.com/watch?v=9LvO7xkueT4

# Constraints

https://docs.flutter.dev/ui/layout/constraints

https://academy.yandex.ru/handbook/flutter/article/widgets-layout

# Animations

https://docs.flutter.dev/ui/animations

# Navigation