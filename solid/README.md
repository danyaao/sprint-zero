# :shipit:
# SOLID

## Принципы SOLID
SOLID - набор принципов, которые помогают писать код, который легко масштабировать и поддерживать.
### S
Single responsibility principle - принцип, суть которого заключается в том, что классы должны делать что-то конкретное и что не стоит создавать супер классы, которые способны выполнять сразу множество задач. Следование этому принципу позволяет уменьшить связанность в коде и избежать ошибок с этим связанных.
### O
Open-closed principle - принцип, суть которого заключается в том, что классы должны быть открыты для расширения, но закрыты для модификации. Следование этому принципу помогает избежать лишней работы с уже написанным кодом и ошибок, которые возникнут во время рефакторинга этого кода.
### L
Liskov substitution principle - принцип, суть которого заключается в том, что классы наследники должны уметь всё, что умеют их родители. Следование этому принципу помогает избежать ошибок, связанных с неочевидным поведением классов наследников.
### I
Interface segregation principle - принцип, суть которого заключается в том, что нельзя создавать супер интерфейсы, из-за которых классам придётся реализовывать ненужные им методы. Следование этому методу помогает избежать написания лишнего и ненужного кода, а также делает код более читаемым.
### D
Dependency inversion principle - принцип, суть которого заключается в том, что модули верхнего уровня, не должны зависеть от модулей нижнего, однако все модули должны зависеть от абстракций, которые в свою очередь не должны зависеть от реализаций. Следование этому методу помогает значительно уменьшить связанность кода, сделать его более надежным и читаемым.

## Почему стоит следовать SOLID
Если не следовать этим принципам, команда разработки обязательно столкнётся с ошибками, которые эти принципы призваны решить, из-за чего все силы будут идти не на разработку приложения, а на фикс багов, поэтому стоит сразу писать хороший код и руководствоваться принципами.

## Real-world SOLID
Программист Вася сделал всемогущий класс, который умеет и ходить в сеть, и в базу данных, и фильтровать и мапить данные. И, скорее всего, этот код даже будет работать. Но через неделю сможет ли Вася разобраться в своём же коде? А будет ли просто ему расширять этот класс дальше? Это вряд ли, а ведь если бы он следовал single responsibility принципу, таких проблем бы не было.
Вася решил немного изменить метод похода в сеть, теперь он возвращает не строку, а список строк, что привело к ошибкам, а этого можно было бы избежать, если бы Вася написал новый метод и следовал open-closed принципу.
Теперь Вася сделал новый класс, который наследуется от его всемогущего класса, но в новом методе он возвращает не список, а хэш таблицу, что привело к огромному количеству ошибок. А если бы Вася следовал liskov substitution принципу, таких проблем бы не было.
Вася сделал огромный интерфейс, в котором были все методы, которые он использует приложение, после чего создал небольшой класс, который имплементируется от него. Сколько же пришлось Васе писать ненужного кода, так ещё ведь он потом и забыл, что половина методов у него это просто затычки, которые на самом деле не работают и получил ошибку. Но если бы он следовал interface segregation принципу, таких проблем бы не было.
Когда Вася писал свой всемогущий класс, в одном из методов на вход он получал context. Однако что-то поменять в слое презентации, он обнаружил, что и доменный слой перестал работать. А если бы Вася следовал dependency inversion принципу, таких проблем бы не было.
