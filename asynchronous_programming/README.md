# :shipit:
# Асинхронность

## Потоки в Dart
Изначально Dart создавался как язык для веба и убийца JS, а в вебе потоков нет, поэтому по историческим причинам Dart не имеет потоков как в C++, Java, Kotlin и т.д., однако есть другой инструмент - изоляты.

## Асинхронностью и многопоточность
Многопоточный код может буквально выполняться параллельно, в одну и ту же секунду. Однако асинхронный код эффективно распределяет задачи.

## Event loop
Асинхронность в Dart'е достигается благодаря event loop. Event loop - бесконечный цикл, который отвечает за порядок выполнения кода. При запуске инициализируются две очереди - microtask и event. Далее, event loop сначала выполняет весь синхронный код, после проверяет наличие microtask'ов, выполняет их все, после проверяет наличие event'ов, выполняет первый, а дальше проверяет, появился ли новый синхронный код или microtask'и и так по кругу. Если обе очереди пусты, выполнение завершается. Работа с очередями идёт по принципу first in first out.

## Изоляты
Изоляты отличаются от привычных потоков тем, что они не умеют шейрить память. Общаться можно только с помощью сообщений через send и receive порты. Каждый изолят имеет свой собственный event loop. И хотя невозможность шейрить память может показаться неудобной, всё-таки она хорошо сказывается на безопасности и читаемости кода.

## Future
Future - generic класс, который может являться результат асинхронной операции. У Future есть три состояния - uncompleted, completed with result и completed with error. Все созданные Future, кроме Future.microtask(), попадают в очередь event'ов в event loop. Чтобы получить результат Future, можно использовать then(), в который передаётся callback. Однако почти всегда используется async/await - синтаксический сахар над then(). Пометив функцию как async, в её теле можно использовать ключевое слово await, с помощью которого можно дождаться результата выполнения Future. Конструкторы Future:
```
Future(FutureOr<T> computation())
Future.delayed(Duration duration, [FutureOr<T> computation()?])
Future.error(Object error, [StackTrace? stackTrace])
Future.microtask(FutureOr<T> computation())
Future.sync(FutureOr<T> computation())
Future.value([FutureOr<T>? value])
```

## Stream
Stream - последовательность асинхронных операций. Если сравнивать его с Future, то, грубо говоря, Stream это последовательность Future. Future стоит использовать, когда нужно выполнить конкретное асинхронное действие, к примеру, отправить в сеть запрос и получить результат. А Stream стоит применять, когда идёт непрерывная работа с асинхронными операциями, к примеру, можно реализовать строку поиска через Stream.

## Stream controller
Stream controller - сущность, которая позволяет создавать Stream и получать доступ к нему. С помощью такого контроллера можно слушать события, а также обрабатывать ошибки. Бывают контроллеры с одиночной и broadcast подписками. Суть первого заключается в том, что он сохраняет всё, что было в Stream'е, однако никто больше этот Stream слушать не может. Суть второго заключается в том, что количество подписчиков не ограничено, однако слушать они начинают с момента подписки и не знают, что было в Stream'е до их подписки. Также Stream'ы можно использовать в качестве state management'а, однако делать это стоит не всегда. Во многих случаях это будет overhead и можно будет ограничиться ValueNotifier'ом или ChangeNotifier'ом. Однако если нужно больше контроля, то можно использовать Stream.

https://dart.dev/tutorials/language/streams

https://www.youtube.com/watch?v=SZGG7uTBXJ4